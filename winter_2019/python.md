# Вопросы по Python

> !!! Все примеры кода написаны на Python 3.8.1

Аббревиатуры:

- ЯП - Язык программирования

## № 1 (Определение и области применения языка программирования Python.)

Python - интерпретируемый, объектно-ориентированный, высокоуровневый ЯП.

Python можно использовать как:

- Средство для обработки текстов
- Механизм доступа к базам данных
- Средство для научных вычислений
- Инструмент для создания приложения
- Инструмент для обработки изображений

## № 2 (Парадигмы программирования, поддерживаемые Python.)

Парадигма программирования - совокупность принципов, методов и понятий, определяющих способов конструирования программы.

Python поддерживает сразу две парадигмы программирования:

1. Императивное (процедурное и объектно ориентированное) - используется набор инструкций изменяющих состояние. Описание алгоритма КАК выполнить задачи.
2. Декларативное (функциональное программирование) - задаётся спецификация решения задачи, то есть описывается ЧТО представляет собой проблема и ожидаемый результат.

## № 3 (Подход к описанию языка Python: алфавит, синтаксис, семантика, прагматика.)

1. Алфавит - перечень допустимых в программе символов (Python - UTF-8)
2. Синтаксис - правила построения сложных конструкция ЯПа из более простых
3. Семантика - смысл синтаксических структур.
4. Прагматика - то что делает интерпретатор на основании переданного

## № 4 (Структура программы и особенности Python. Кодировка строк кода по умолчанию.)

Структура программы:

- Каждая инструкция располагает на отдельной строке
- Концом инструкции является конец строки
- Отсутствие символов для выделения вложенных инструкций
- Если блок состоит из одной инструкции, то допустимо разместить её на одной строке с основной инструкцией

Кодировка Python - UTF-8

## № 5 (Разбиение логических строк, написание комментариев, задание многострочного текста.)

- Для разбиения логических строк - `\`
- Для комментарий - `#`
- Для многострочного текста - `"""` либо `'''` также можно использовать `\n` для обычных строк

## № 6 (Синтаксис и пример функции вывода с использованием форматирования в Си-стиле.)

В python строки имеют встроенный оператор % с помощью которого происходит из форматирования. У данного оператора только один аргумент (либо одно значение, либо кортеж, либо словарь). Для вставки нужно в строке поставить метки.

Примеры меток (не все):

- %s (`str`) Строки
- %d (`int`) Целые числа
- %f (`float`) Дробные числа
- %с (`str`) Символ

```python
words = {'hello': 'Hello', 'world': 'World'}
world = 'World'
print('Hello %s' % world)  # Output: 'Hello World' (одно значение)
print('%s %s' % ('Hello', world))  # Output: 'Hello World' (кортеж)
print('%(hello)s %(world)s' % words)  # Output: 'Hello World' (словарь)
```

## № 7 (Синтаксис и пример функции вывода с использованием метода *format()*.)

>  **format(value[, format_specs])**

Функция для форматирования строк. Аргументы:

- value - значение для форматирования (`str`)
- fomat_specs - значения для вставки

Для вставки используются метки:

- {} - по порядку
- {1} - по номеру аргумента
- {name} - для именованных аргументов

```python
print('{} {}'.format('Hello', 'World'))  # Output: 'Hello World' (по порядку)
print('{1} {0}'.format(''))  # Output: 'Hello World' (по номеру аргумента)
print('{a} {b}'.format(a='Hello', b='World'))  # Output: 'Hello World' (именованные аргументы)
```

## № 8 (Синтаксис и пример функции ввода с получением действительного числа.)

> **input([prompt])**

Функция для чтения введённой строки, возвращает `str`. Аргументы:

- prompt - строка, которая выведется перед вводом текста

```python
integer = int(input('Enter some int: '))  # int нужен для перевода строки в целое число (при ошибке вызовет ValueError)
```

##  № 9 (Объекты в Python. Переменные (идентификаторы). Встроенные имена *builtins*.)

1. Объект в python - абстракция над данными, так как все данные представлены в виде объектов или отношениями между ними.

2. Переменная в python - ссылка на объект. Правила для создания переменной:

    - Не может начинаться с цифры
    - Могут содержать букву (любую), цифру и символ нижнего подчёркивания
    - Чувствительны к регистру (g != G)

3. builtins - встроенные функции и переменные. Для получения всего списка:

    ```python
    import builtins
    print(dir(builtins))
    ```

## № 10 (Динамическая типизация. Множественное присваивание. Оператор *is*.)

1. Python имеет динамическую типизацию, это значит что при присваивании переменной не нужно указывать тип (это определит интерпретатор). Также это значит что переменная сможет менять тип после объявления.

2. Множественное присваивание - одновременное присваивание нескольких значений сразу нескольким переменным

   ```python
   a, b, c = 1, 2, 3  ## Присваивание 1 для a и 2 для b
   a, *b = 1, 2, 3  ## Присваивание 1 для a и 2, 3 для b
   *a, b = 1, 2, 3  ## Присваивание 1, 2 для a и 3 для b
   ```

3. Оператор `is` служит для проверки ссылаются ли две переменные на один объект (работает для immutable объектов)

## №11 (Области видимости имён в Python. Связывание имён со значениями.)

В python есть 3 области видимости имён:

1. Локальная - имена в функциях (уничтожаются после её выполнения)
2. Глобальные - имена из разных модулей и самой программы
3. Встроенные - имена, которые содержат встроенные функции и исключения

Правила присваивания(связывания имён со значениями):

- Создание переменной происходит при использовании оператора `=`, `import`, `import as` или в конструкциях `with`, `for`, `try-except as`
- Переменная должна быть создана до её использования, иначе будет ошибка NameError 

## № 12 (Реализация в Python основных алгоритмических конструкций.)

Вложенные конструкции должны иметь одинаковый отступ, обычно 4 пробела (PEP 8).

- `if-elif-else` условный оператор

  ```python
  a = 2
  if a == 0: 
  	print('zero')
  elif a == 1:
      print('one')
  else:
      print('something else')
  ```

- `for` цикл с параметром

  ```python
  for i in [0, 1, 2]:
  	print(i)
  ```

- `while` цикл с предусловием

  ```python
  while True:
  	print('infinity')
  ```

## №13 (Назначение и применение операторов *continue*, *break*.)

1. Оператор `continue` служит для прерывания одной итерации цикла и перехода к следующей
2. Оператор `break` служит для прерывания цикла и выхода их него до его полного завершения

## №14 (Написание и вызов функций. Оператор **def**, **lambda**-выражение.)

1. Оператор `def` служит для создания функции и определения её параметров и выражений

   ```
   def <function>(parameters):
   	expression 1
   	expression 2
   	...
   ```

2. Оператор `lambda` служит для создания анонимных функций

   ```
   func = lambda <parameters> : expression
   ```

   Аналог `def`:

   ```
   def <lambda>(parameters):
   	return expression
   ```

Правила написание функций:

- Необязательные параметры идут после обычных (`def add(a, b = 2)`)
- Функции могут ничего не возвращать, или вернуть один или несколько объектов через оператор `return`

Пример

```python
def add(a, b):
    return a + b

multiply = lambda a, b : a * b

print(add(3, 2))  # Output: 5
print(multiply(3, 2))  # Output: 6
```

## № 15 (Использование механизма исключений. Иерархия исключений.)

Для перехвата исключений есть `try-except`.

```python
# try-except со всеми 
try:
    a = 1 + True
except TypeError:
    print('TypeError(')
except SyntaxError:
    print('SyntaxError(')
else:
    print('All is OK. There\'s gonna be 2')
finally:
    print('There\'s no error')
```

Встроенные исключения (не все):

- Exception - родитель всех исключений
- ZeroDivisionError
- FloatingPointError
- AssertionError
- EOFError
- ImportError
- KeyboardInterrupt
- NameError
- TypeError
- UnicodeError

## №32 (Понятие паттерна проектирования. Типы паттернов.)

Паттерн проектирования - допускающие многократное использование оптимизированные решения проблем программирования.

Типы паттернов:

- Порождающие паттерны - паттерны которые работают с механизмом создания объектов (Abstract Factory, Builder, Prototype)
- Структурные паттерны - паттерны определяющие, как из классов и объектов образуются более крупные структуры (Adapter, Bridge, Composite)
- Поведенческие паттерны - паттерны определяющие способы взаимодействия классов и объектов (Iterator, Interpreter, State)

## № 33 (Событийно-управляемое программирование. Сферы применения. Типы событий.)

EDP (Event-Driven Programming) - парадигма программирования, к которой выполнение программы определяется событиями.

Применяется в 3-х случаях:
1. При построении UI
2. При создании серверных приложений в случае, если по тем или иным причинам нежелательно порождение обслуживающих процессов
3. При программировании игр, в которых осуществляется управление множеством объектов

События:

- Клавиатуры
- Мыши
- Формы

## № 34 (Графический интерфейс пользователя. Разновидности.)

GUI (Graphical User Interface) - разновидность пользовательского интерфейса, в котором элементы интерфейса представлены пользователю на дисплее в виде графических изображений.

Разновидности:

- Простой - типовые экранные формы и стандартные элементы интерфейса, обеспечиваемые самой подсистемой GUI
- Двумерный
- Трёхмерный

## № 37 (Графическая библиотека *tkinter*. Создание окна.)

Tkinter - графическая библиотека позволяющая создавать приложения с оконным интерфейсом.

Пример создания окна:

```python
# Создание окна
from tkinter import *

root = Tk()  # Tk app
root.title('Example window')  # Main window title

root,mainloop()  # Start app drawing
```

## №47 (Понятие оптимизации программного кода, её основные принципы.)

>  Оптимизация - модификация программного кода для улучшения его эффективности

Основные принципы оптимизации кода:

- Естественность - код должен быть аккуратным, модульным и легко читабельным
- Производительность - после оптимизации должен быть прирост производительности ПО
- Время - оптимизация и последующая отладка должны занимать небольшой период времени

## № 48 (Методы оптимизации программного кода. Ясность и структурированность.)

- Соответствие стандартам оформления - в случае Python использование правил **PEP** (Python Enhancement Proposals)
- Использование инструментов статистического анализа - таких как pylint и pychecker. Они предоставляют отчёт с метрикой и статистикой, помогающей более объективно оценить качество кода.
- Документирование кода

## № 49 (Методы оптимизации программного кода. Экономия памяти.)

- Удаление ненужного функционала
- Генераторы для вычисления большого количества результатов
- Кортежи вместо списков при генерации большого количества неизменяемых последовательностей
- `format`, `%`, `join` для конкатенации длинных строк вместо `+` (при копировании с помощью `+` создаётся новая строка)
- Меморизация (сохранение значения, возвращаемого функцией для заданных аргументов) и кэширование (сохранение результатов чего угодно)

## № 50 (Методы оптимизации программного кода. Увеличение производительности.)

- Последняя версия Python
- Встроенные функции языка (так как они лучше проработаны)
- Переписывание на другой язык частей программы
- Проектирование и структура данных
- Распараллеливание и распределения нагрузки
- Виртуальная среда (помогает избежать конфликта версий зависимостей)
- Анализ кода
- Тестирование и дальнейшая интеграция

## № 51 (Профилирование кода на Python. Анализируемые параметры. Методы профилирования.)

>  Профилирование - сбор характеристики работы программы с целью их дальнейшей оптимизации

Анализируемые параметры:

- время выполнения строк кода
- количество вызовов и время выполнения отдельных функций 
- дерево вызовов функций
- загрузка CPU и RAM
- обращение к другим ресурсам компьютера

Методы профилирования:

- Метод пристального взгляда
- Ручное профилирование
- Профилирование с помощью инструментов (profile, timeit)

## № 52 (Профилирование кода на Python. Применение модулей *profile*, *pstats*, *timeit*.)

>  Профилирование - сбор характеристики работы программы с целью их дальнейшей оптимизации

1. profile - модуль для профилирования кода

   Для профилирование требуется запустить функцию или часть кода через `profile.run()`

   ```python
   import profile
   
   profile.run('[[j for j in range(100)] for i in range(100)]')
   ```

   Метрики:

   - ncalls – количество совершенных вызовов
   - tottime – всё время, потраченное в данной функции
   - percall – tottime, деленный на ncalls
   - cumtime – совокупное время, потраченное как в данной функции, так и наследуемых функциях
   - percall – это cumtime деленный на примитивные вызовы
   - filename:lineno(function) – данные о каждой функции

2. pstats - для сортировки отчёта из модуля profile

   Скрипт выводит таблицу для пяти самых затратных по времени работы (без учета дочерних вызовов) функций.

   ```python
   import profile
   import pstats
   
   profile.run('[[j for j in range(100)] for i in range(100)]', 'generator')
   stats = pstats.Stats('generator')
   stats.strip_dirs()
   stats.sort_stats('time')
   stats.print_stats(5)
   ```

3. timeit - библиотека для измерения времени запуска программы или модуля.

   Запускает программу 10000 раз и показывает время самого быстрого результата

   ```python
   import timeit
   
   timeit.timeit('[[j for j in range(100)] for i in range(100)]', number=10000)  # Output 3.4858554290003667
   ```

   

## № 53 (Эвристические правила разработки интерфейсов пользователя.)

- Информированности о состоянии системы (взаимодействие пользователя с системой как можно более логичное)
- Схожесть системы с реальным миром (использование слов, фраз и понятий, знакомых пользователю, вместо узкоспециальных терминов)
- Свобода действий пользователя (возможность отмены действий, возврата к ранее отмеченным действиям)
- Единообразие и стандарты
- Предотвращение ошибок
- Все должно быть на виду (пользователь не обязан запоминать большое количество объектов, действий и опций)
- Гибкость и эффективность (совершение часто повторяющихся действий как можно быстрее и проще)
- Эстетичный и минималистичный дизайн
- Понимание проблем и их решение (сообщения об ошибках должны быть на понятном пользователю языке, предлагать решение проблемы)
- Справочные материалы и документация

## № 54 (Принципы построения интерфейсов. Стратегия разработки.)

Принципы построения интерфейсов:

- Золотое сечение (самая комфортная для глаза пропорция, форма, в основе которой лежит формула **(a+b):a=a:b**)
- Кошелёк Миллера (при группировке кнопок, пунктов меню, закладок, опций и т.д. в одной группе должно быть **7±2** элементов)
- Принцип группировки (экран приложения должен быть разделен на ясно очерченные блоки элементов, возможно, с заголовками, группировка должна быть осмысленной)
- Бритва Оккама (решение задачи за минимальное число действий очевидным способом с оптимизацией движения курсора и даже глаз пользователя - принцип KISS (keep it simple, stupid))
- Видимость отражает полезность (вынесение важной информации и элементов управления на первый план, перемещение менее важной на второй план, например, в меню)
- Умное заимствование (использование широко распространённых приёмов дизайна интерфейсов и удачных находок)

Стратегия разработки:

- Разрабатывать интерфейс как отдельный компонент системы
- Учитывать возможности аппаратных и программных средств
- Соблюдать этапы в разработке
- Использовать общепринятые принципы разработки интерфейсов
- Соответствовать постановке задачи и ожиданиям пользователя
- Привлекать, но не утомлять пользователя
- Предусмотреть средства адаптации в рамках интерфейса

## № 55 (Этапы разработки интерфейсов пользователя.)

1. Исследование предметной области
2. Пользовательские сценарии
3. Структура интерфейса
4. Прототипирование интерфейса
5. Определение стилистики
6. Дизайн и концепция
7. Оформление всех экранов
8. Анимация интерфейса
9. Подготовка материалов для разработки
10. Реализация программно-инструментальными средствами

## № 56 (Проектирование интерфейса пользователя. Понятие юзерфлоу, вайрфрейма.)

Проектирование интерфейса предполагает создание:

- Карты окон, экранов (User Flow Diagram) - переход пользователей от одного экрана (окна) приложения к другому, то есть сценария взаимодействия с интерфейсом.
- Плана расположения элементов (Wireframes) - образ дизайна низкой точности, отображающий основные группы контента, из структуру и базовую визуализацию взаимодействия с пользователем.
- Детализированных макетов (Mock-up)
- Прототипов

## №57 (Проектирование интерфейса пользователя. Понятие мокапа, прототипа.)

Проектирование интерфейса предполагает создание:

- Карты окон, экранов (User Flow Diagram)
- Плана расположения элементов (Wireframes)
- Детализированных макетов (Mock-up) - неработающая графическая модель, выполненная в натуральную величину и выглядящая так, как будет выглядеть работающий экземпляр
- Прототипов - симуляция финального взаимодействия между пользователем и интерфейсом